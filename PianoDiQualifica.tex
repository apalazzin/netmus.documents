
\newcommand{\nomedoc}{Piano Di Qualifica}
\newcommand{\versione}{1.2}
\newcommand{\versioneglossario}{1.0}
\newcommand{\versionenormeprogetto}{1.0}
\newcommand{\versioneAR}{1.0}
\newcommand{\nomefile}{PianoDiQualifica-\versione.pdf}
\newcommand{\datacreazione}{3 Dicembre 2010}
\newcommand{\datamodifica}{21 Gennaio 2011}
\newcommand{\stato}{formale}
\newcommand{\uso}{esterno} 
\newcommand{\redazione}{Trezzi Giovanni}
\newcommand{\verifica}{Palazzin Alberto}
\newcommand{\approvazione}{Lovato Daniele}
\newcommand{\distribuzione}{ 
VT.G \\
& Prof. Vardanega Tullio\\
& Prof. Cardin Riccardo }

\input{preambolo.tex}

\begin{document}

\input{homepage.tex}

% REGISTRO MODIFICHE
\section*{Registro delle modifiche}

\begin{longtable}{|p{0.13\textwidth}|c|p{0.2\textwidth}|p{0.46\textwidth}|}
\hline
\rowcolor{orange} \bo{Data} & \bo{Versione} & \bo{Autore} & \bo{Descrizione} \\
\hline
\endhead
\hline
\endfoot
21/01/2011 & 1.2 & Mandolo Andrea & Corretti Riferimenti.\\
\hline
12/01/2011 & 1.1 & Mandolo Andrea & Modificato layout Registro delle
modifiche.\\
\hline
19/12/2010 & 1.0 & Lovato Daniele & Validazione per consegna RR.\\
\hline
18/12/2010 & 0.6 & Palazzin Alberto & Verificato l'intero documento.\\
\hline
18/12/2010 & 0.5 & Trezzi Giovanni & Corretti errori di grammatica, sintattici
ed ortografici. Corretta la sintassi del paragrafo 3.2 del paragrafo 4.2 e
4.2.3.\\
\hline
13/12/2010 & 0.4 & Trezzi Giovanni & Corretti errori di battitura nel Sommario.
Modifiche sintattiche in 2.1. Scorporato 2.1.1 in 2.1.2, 2.1.3, 2.1.4. Modifica della
struttura di 2.1.2 in elenco puntato. Corretto errore grammaticale in 2.1.3.
Modifica sintattica in 2.1.4, in 2.2 e in 2.3.\\
\hline
3/12/2010 & 0.3 & Trezzi Giovanni & Corretto il contenuto del Sommario. Corretto
il paragrafo 1.2 ``Scopo del documento''. Modificato 2.1 integrando l'attivit\`a
di validazione nel discorso. Corrette le maiuscole/minuscole negli elenchi
puntati in 2.1.1, in 3.2 e 5. Corretto un errore di battitura in 3.3.1.
Modificato parte di 4.2 per maggior chiarezza di lettura.\\
\hline
13/12/2010 & 0.2 & Trezzi Giovanni & Correzione errori di battitura nei
paragrafi 2.1 3.1.2. Correzione punteggiatura degli elenchi puntati di tutto il documento.
Aggiunta la versione dei documenti a cui si fa riferimento.\\
\hline
03/12/2010 & 0.1 & Trezzi Giovanni & Stesura prima versione del documento.\\
\end{longtable}


% INDICE
\tableofcontents


\chapter*{Sommario}
Nelle pagine del presente documento saranno descritte le modalit\`a di verifica
e validazione che si intendono adottare e che verranno utilizzate durante
l'intero ciclo di vita del progetto, a partire dalla stesura dell'intera
documentazione fino alle ultime fasi di collaudo del software prima della
consegna del prodotto finale. Il Piano di Qualifica rappresenta di fatto il
punto di riferimento in cui sono contenute le linee guida da seguire per tutte
le attività di verifica e validazione.


\thispagestyle{fancy} % serve perche' nelle pagine di inizio Chapter esca header e footer
\pagenumbering{arabic} % INIZIO NUMERAZIONE NORMALE
\rfoot{\thepage\ di \pageref{TotPages}}
\addcontentsline{toc}{chapter}{Sommario}

\chapter{Introduzione}
\thispagestyle{fancy} % serve perche' nelle pagine di inizio Chapter esca header e footer

\section{Scopo del documento}

Il presente documento fornisce le strategie di \underline{verifica} e
\underline{validazione} che verranno attuate durante lo sviluppo del progetto al
fine di evitare ed eventualmente correggere anomalie e/o difetti all'interno del
sistema e per garantire l'insieme delle caratteristiche e proprietà che, nel
loro complesso, rappresentano la qualità del prodotto finale.

\input{parte_comune.tex}

% INIZIO CAPITOLO 2

\chapter{Visione generale della \\strategia di verifica}
\thispagestyle{fancy} % serve perche' nelle pagine di inizio Chapter esca header e footer

\section{Organizzazione, pianificazione strategica e \\temporale,
responsabilit\`a}

Lo scopo che ci si prefigge è quello di garantire la più alta
\underline{qualità} possibile per quello che sarà il prodotto finale. Con lo
scopo di garantire un'elevata qualità, verranno stabilite precise procedure di
verifica su tutti i prodotti di ogni singola fase di lavoro, verranno indicati
gli strumenti con i quali effettuare le operazioni di verifica e verranno
indicate le strategie elaborate per poter operare in tal senso e ai fini di una
corretta validazione. Ogni singola modifica o l'insieme di pi\`u modifiche
comporteranno una conseguente attivit\`a di verifica. Al fine di
ottimizzare tempo e risorse, le attivit\`a verranno effettuate solamente quando
una singola o pi\`u modifiche avranno comportato differenze di tipo rilevante
all'interno di ogni fase del progetto. La validazione dovrà avvenire
solamente a fronte di una precisa e meticolosa attività di verifica e nel
rispetto di tutti i requisiti e le specifiche, senza discostarsi da
quanto inizialmente concordato. Sar\`a dovere del responsabile accertarsi che
tutte le attivit\`a si svolgano nelle modalit\`a descritte nel presente documento.
\\
\\ 
Come punto di riferimento per quanto riguarda la misurazione e quindi la
quantificazione della qualità di ogni singolo processo nello sviluppo del
software faremo riferimento alla normativa ISO 15939 dove la misurazione del
software viene indicato come un processo iterativo PDCA, con 4 attività
principali.
\\
\\
\includegraphics[height=4cm]{img/pdca.png}
\\

Nel presente capitolo verranno definite le esigenze di misurazione che si
ritengono necessarie ai fini della qualità, ovvero verrà indicato cosa per ogni
singola fase del progetto sarà necessario verificare. Verranno indicati gli
strumenti con i quali effettuare la verifica e verranno indicate le metriche con
le quali misurare le proprietà di ciò che si sta verificando. Verranno indicate
infine le tecniche con le quali procedere. Una volta volta terminata l'attività
di verifica e la conseguente attività di misurazione, si procederà con il
riportare l'esito nel capitolo 4 del presente documento. Una volta terminata
l'attività di misurazione sulla base dei risultati si valuteranno eventuali
decisioni, manovre correttive o l'accettazione del prodotto verificato secondo
le misure e i criteri stabiliti.


\subsection{Feedback di valutazione}
Per una migliore comprensione su come alcuni fattori posso influenzare
 le varie fasi del progetto è stato introdotto un
sistema di feedback su tutte le attività svolte. Ogni volta che
qualcuno porta a termine un'attività viene raccolto una valutazione in termini
di soddisfazione su uno dei seguenti aspetti:

\begin{itemize}
\item lavoro svolto;
\item interazione con gli altri;
\item strumenti utilizzati;
\item tempo impegato;
\end{itemize}

La valutazione può essere assegnata in una scala numerica da 1 a 10. Alla fine
di ogni fase di progetto verrà sviluppato un grafico riassuntivo con la media dei
punteggi per ogni singola voce. I risultati ottenuti confrontati con le
valutazioni ricevute in fase di revisione potrà fornire interessanti spunti su
come correggere o rafforzare il metodo di lavoro.


\subsection{Verifica della documentazione}

Per ogni documento dovranno essere verificati i seguenti aspetti:
\begin{itemize}
\item correttezza semantica e grammaticale;
\item chiarezza espositiva;
\item assenza di errori concettuali;
\item comprensibilità e accuratezza;
\item correttezza e completezza dei concetti espressi;
\item formattazione del documento secondo quanto specificato dall'amministratore
in\\ \emph{NormeDiProgetto-\versionenormeprogetto.pdf}.
\end{itemize}

Nel caso sia necessario intervenire per correggere uno o pi\`u di questi aspetti
sar\`a dovere del verificatore contattare il redattore del documento affinch\`e
questo gestisca le relative attivit\`a di modifica. Una volta modificato, il
documento dovr\`a essere nuovamente sottoposto all'attenzione del verificatore
per una nuova attivit\`a di verifica.


\subsection{Verifica della fase di analisi}

La fase di analisi dovr\`a essere verificata secondo i seguenti aspetti:

\begin{itemize}

\item costi;
\item scheduling;
\item completenza rispetto al modello FURPS.
 

\end{itemize}

Il modello FURPS, elaborato inizialmente da RoberGrady presso i laboratori
dell'Hewlwtt-Packard. \`E un acronimo mnemonico per la definizione dei requisiti
di software di vario genere e sta a significare:

\begin{itemize}

\item F - Functionality (capacità di fornire le funzioni richieste);
\item U - Usability (facilità d'uso dell'utenza finale);
\item R - Reliability (gestione degli errori e dei crash);
\item P - Performance (Prestazioni);
\item S - Supportability (Supportabilità).
\end{itemize}


Nel caso sia necessario intervenire in maniera correttiva rispetto ad uno o
pi\`u di questi aspetti sar\`a dovere del verificatore contattare l'analista
responsabile affinch\`e provveda alle relative modifiche.



\subsection{Verifica della fase progettuale}

La fase di progettazione dovr\`a essere verificata secondo i seguenti aspetti:

\begin{itemize}

\item soddisfacimento di tutti i requisiti individuati nel documento
\emph{AnalisiDeiRequisiti-\versioneAR.pdf};
\item individuazione di elementi progettuali superflui, non aderenti a nessun
requisito richiesto;
\item corretta corrispondenza e tracciabilit\`a tra i requisiti e le relative
parti del progetto;
\item flessibilità;
\item manutenibilità.

\end{itemize}

Nel caso sia necessario intervenire in maniera correttiva rispetto ad uno o
pi\`u di questi aspetti sar\`a dovere del verificatore contattare il progettista
responsabile affinch\`e provveda alle relative modifiche riguardanti la progettazione.

\subsection{Verifica della fase di realizzazione/programmazione}

La fase di realizzazione/programmazione dovr\`a essere verificata secondo i seguenti aspetti:
\begin{itemize}
\item Corretto funzionamento dell'applicazione;
\item Affidabilit\`a;
\item Efficienza;
\item Portabilit\`a;
\item Manutenibilit\`a.

\end{itemize}

Nel caso sia necessario intervenire sul codice in base ad uno di questi aspetti
sar\`a dovere del verificatore contattare il programmatore responsabile della
relativa porzione di codice.

Inoltre, per favorire l'attivit\`a di verifica, ogni programmatore sar\`a tenuto
ad eseguire attivit\`a di debugging sul codice per cercare di diminuire le
possibilit\`a d'errore.

\subsection{Validazione}

L'impegno che ci si assume \`e quello di fornire un prodotto completamente e
correttamente funzionante secondo i requisiti concordati. Qualora venissero
riscontrati difetti o non conformit\`a, durante la verifica in fase di collaudo,
ci si impegna ad effettuare modifiche o interventi necessari per risolvere i
problemi.

\section{Risorse necessarie e disponibili}

Per la fase di qualifica sono necessarie risorse di tipo umano che
effettueranno attivit\`a di verifica e validazione cos\`i come definito nel
presente documento. Sono necessarie inoltre risorse di tipo logistico quali
programmi per le attivit\`a di tracciamento tra i requisiti e i moduli software,
un \underline{framework} per i test specifici di unit\`a del codice, un
applicativo software per la gestione e la risoluzione delle anomalie, un ambiente di sviluppo
adeguato con possibilit\`a di effettuare debugging da parte dei programmatori.

\section{Principi e linee guida}

La verifica deve sempre portare alla conferma che si stia lavorando nel modo
corretto.

\begin{itemize}
\item I collaudi devono essere pianificati con largo anticipo. La pianificazione
dei collaudi può iniziare non appena si è completata la definizione e specifica
dei requisiti. La definizione dei casi di prova può cominciare appena il modello
progettuale è stabile.
\item Il tracciamento è la componente fondamentale della verifica in quanto ogni
parte del software deve essere conforme e soddisfare i requisiti.
\item Principio di Pareto: l'80\% degli errori è riconducibile al 20\% dei
componenti del programma. Il problema è identificare ed isolare i componenti
sospetti.
\item Per essere efficace, il collaudo dovrebbe essere condotto da una parte
indipendente, non da chi ha scritto il codice.
\end{itemize}	
	
\section{Strumenti}

Per le attivit\`a di verifica ci avvarremo dei seguenti strumenti:\\

LISTA DA RIVEDERE AMPLIARE E AGGIUSTARE

\begin{itemize}

\item Junit: come unit test framework per il linguaggio di
programmazione \underline{Java};

\item Emma: per il calcolo della copertura del codice;

\item Eclipse + \underline{GWT}: per le funzionalit\`a di debug di Eclipse su
codice Java mentre l'applicazione da testare verr\`a eseguita in hosted mode
tramite GWT;

\item Google Project Hosting: per la funzionalit\`a issue-tracker
per la gestione e creazione di ticket cos\`i come descritto nel documento \emph{NormeDiProgetto-1.0.pdf};

\item FindBugs: per effettuare analisi statica del codice
sorgente Java al fine di trovare errori comuni;

\item Metrics: per calcolare la misura di varie metriche del
codice sorgente durante la fase di compilazione in modo da tenere continuamente
sotto controllo lo stato del codice stesso;

\item Cobertura: per misurare la carenza di test di unit\`a
all'interno di un progetto (misurare la percentuale di linee di codice che
vengono controllate dai test di unit\`a, la percentuale di diramazioni del
codice che vengono controllate dai test di unit\`a, la complessit\`a ciclomatica
di ogni classe e il numero di volte che una linea di codice \`e stata eseguita
dai testi di unit\`a);

\item CheckStyle: come aiuto per garantire che il codice Java
aderisca alle pi\`u diffuse norme di codifica.
\end{itemize}


\section{Metriche}

Una metrica viene definita come un metodo di misura associato ad una scala di
valutazione. Secondo il glossario IEEE una metrica è la misura quatitativa del
grado con cui una entità possiede un determinato attributo.

Ai fini della valutazione e quindi di un possibile miglioramento o
correzione della qualità del prodotto finito, devono essere stabilite delle
misure precise con cui misurare quantitativamente i prodotti delle varie fasi
progettuali.\\
\\
\\
TUTTE LE METRICHE DI SEGUITO SONO SOLAMENTE ELENCATE, VANNO SCELTE E DISCUSSE


\subsection{Misure nell'analisi dei requisiti}

\begin{itemize}
  
\item numero di requisiti;
\item functions Points (requisiti funzionali);
\item volatilità dei requisiti;

\end{itemize}


\subsection{Misure nella progettazione}

\begin{itemize}
  
\item numero di moduli in uno schema di progettazione;
\item livello di coesione tra i moduli;
\item livello di accoppiamento (copuling) tra moduli;
\item complessità di flusso (quantità di informazioni in entrata ed uscita da
una funzione in ragione della lungezza in LOC);

\end{itemize}


\subsection{Misure sul codice}

\begin{itemize}
  
\item LOC linee di codice;
\item complessità ciclomatica;
\item misure di Halstead (1977, combinazione di 5 elementi);
\item misure di complessità;
\item misure object oriented;
\item misure di coesione funzionale;

\end{itemize}


\subsection{Misure sui test}

\begin{itemize}
  
\item livello di copertura di istruzioni;
\item livello di copertura dei rami;
\item livello di copertura dei percorsi di base;
\end{itemize}



  
\subsection{Misure sui processi} 

\begin{itemize} 
\item tempo per le attività del processo fino al suo completamento;
\item risorse richieste dal processo o le sue attività (ad esempio le quantità
totali di ore/persone).
\item Soddisfazione degli Stakeholder  
\end{itemize}

Qualora la qualità del processo risultasse minore di quella preventivata,
si avranno dei parametri per la stima del costo del miglioramento della qualità
del processo e quindi del prodotto.



\section{Tecniche di Verifica}

L'analisi (verifica) si pone come obiettivo di identificare i difetti presenti nel sistema e in tutte le sue fasi di progettazione.
Essa può essere divisa in due parti fondamentali:

\begin{itemize}

\item Analisi Statica;
\item Analisi Dinamica. 

\end{itemize}

queste due tecniche verranno approfondite nei successivi paragrafi.


\subsection{Analisi Statica}

AGGIUNGERE UNA PICCOLA DESCRIZIONE GENERALE RELATIVAMENTE ALL'ANALISI STATICA

\vspace{1cm}
\begin{table}[h]
\begin{center}
\begin{tabular}{|l|c|}
\hline
\rowcolor{orange}
\bo{Sigla}  & \bo{Descrizione} \\
\hline TR & Tracciamento \\ \hline
WT & Walkthrough \\ \hline
IN & Inspection \\ \hline
AFC & Analisi flusso di controllo \\ \hline
AFD & Analisi del flusso di dati \\ \hline
AFI & Analisi del flusso d'informazione \\ \hline
ES & Esecuzione simbolica \\ \hline
VDC & Verifica consistenza dati e peso del codice \\ \hline
VLC & Verifica corretta logica del codice \\ \hline
VFC & Verifica formale del codice \\ \hline
ATC & Analisi temporale del codice \\ 
\hline
\end{tabular}
\caption{Analisi Statica}
\end{center}
\end{table}


\subsubsection{Tracciamento}

Con il tracciamento si intende mappare l'evoluzione dei requisiti nel corso del
progetto in modo tale da consentire durante le varie fasi di capire quali
requisiti sono stati soddisfatti e quali non ancora o di avere un quadro
generale sullo stato del progetto globale. In fase di progettazione si dovrà
controllare che ogni requisito sia implementato correttamente e allo stesso
tempo non esista alcuna funzionalità superflua o componenti inutili. Il
tracciamento deve essere bidirezionale cioè esista una
corrispondenza biunivoca tra la fonte e l'oggetto del tracciamento.

\subsubsection{Walkthrough}

Questa tecnica consiste nella verifica critica dei dati senza
l'assunzione di presupposti e nella simulazione di possibili esecuzioni con l'obiettivo
di rivelare eventuali difetti.

\subsubsection{Inspection}

Questa tecnica consiste in una verifica mirata dei dati rispettivamente a
determinate metriche con il preciso scopo di trovare determinati tipi di errori.
Prevede la preparazione preliminare del gruppo prima dell'incontro: ogni membro esamina il prodotto, eventualmente applicando tecniche analitiche.

\subsubsection{Analisi flusso di controllo}

Quest'analisi controlla il codice con lo scopo di determinare se è scritto in
modo strutturato e se esegue nel modo desiderato. Controlla inoltre che non ci
sia codice sintatticamente irraggiungibile e cerca parti del codice che possono
portare a terminazioni non desiderate, come chiamate ricorsive e/o iterazioni.

\subsubsection{Analisi del flusso di dati}

Accerta che nessun cammino d'esecuzione del programma acceda a variabili prive
di valore, usa i risultati dell'analisi di flusso di controllo insieme alle
informazioni sulle modalità di accesso alle variabili (lettura, scrittura).
Rileva possibili anomalie, per esempio più scritture successive senza letture
intermedie. \`E complicata dalla presenza e dall'uso di dati globali accedibili
da ogni parte del programma.

\subsubsection{Analisi del flusso d'informazione}

Quest'analisi va a determinare ed analizzare le dipendenze create tra gli
ingressi e le uscite di un'unità di codice durante la sua esecuzione. Le uniche
dipendenze possibili sono quelle previste dalla specifica, eventuali altre
dipendenze sono da considerarsi errate. Consente inoltre di identificare
eventuali effetti collaterali e può essere applicata a singoli moduli o a più
moduli collegati o all'intero sistema.

\subsubsection{Esecuzione simbolica}

Unisce le tecniche di analisi di flusso di controllo, analisi di flusso dei dati
e analisi di flusso d'informazione, verifica le proprietà del programma mediante
la manipolazione algebrica del codice sorgente tramite ``sostituzioni inverse''.

\subsubsection{Verifica consistenza dati e peso del codice}

Verifica che i dati restino entro il limite del loro tipo e della precisione
desiderata, considerando quindi gli arrotondamenti, il problema dell'overflow e
la gestione dei valori di limite. Si occupa anche dell'analisi e di una corretta
gestione dello heap.

\subsubsection{Verifica corretta logica del codice}

Si propone di accertare che il codice sia ben strutturato ed esegua nella
sequenza attesa. Si occupa inoltre di verificare che nessun cammino
d'esecuzione del programma acceda a variabili prive di valore.

\subsubsection{Verifica formale del codice}

Esplora tutte le esecuzioni possibili mediante prove statiche per rilevare
difetti non sollevati dai test di unità. Si riferisce all'intero sistema integrato.

\subsubsection{Analisi temporale del codice}

Si occupa di verificare che nell'esecuzione del sistema totale le funzioni più
importanti e gli eventuali algoritmi usati eseguano in modo da dare la risposta
attesa in proporzione al carico di informazioni in ingresso.

\subsection{Analisi dinamica}
In base al ciclo di vita adottato, ossia il modello incrementale, verranno effettuati dei 
test di integrazione adottando un modello di integrazione incrementale. 
Non \`e infatti conveniente riunire l'intero sistema e collaudarlo, ma la
strategia utilizzata sar\`a integrazione top-down. Ci\`o significa che i moduli
saranno gradualmente integrati in sottosistemi, effettuando opportune verifiche della loro  corretta interazione. 
L'integrazione incrementale top down richiede l'utilizzo di molti stub che sostituiscano 
le componenti; spesso questi stub presentano degli errori dato che sono dei semplici 
prototipi realizzati rapidamente per diminuire i costi, ma permette il funzionamento di 
un sistema parziale molto pi\`u in fretta rispetto ad un modello bottom up.\\
\\
L'integrazione top down richiede che ogni componente venga sostituita da uno stub, 
a partire dalle foglie nell'albero delle dipendenze, e man mano che si scende si 
inseriscono sempre più componenti al posto degli stub. 
Lo schema del procedimento da seguire è il seguente:

\begin{itemize}
  \item si progetta, scrive e testa una parte del sistema
  \item se ne scrive un altro pezzo
  \item si integrano le due parti e si testa
  \item ogni malfunzionamento rilevato sar\`a conseguenza del malfunzionamento
  dell'ultima componente aggiunta
\end{itemize}


\subsubsection{Test di Unit\`a}
Il seguente paragrafo intende illustrare i procedimenti seguiti durante i test
di ogni singola unit\`a.\\
La verifica del codice adotterà 2 modelli:

\begin{itemize}
  \item Verifica funzionale dei requisiti(black box): questo modello si basa su un sistema 
di test a scatola chiusa, ossia partendo dalla conoscenza della struttura interna del 
prodotto, verranno controllati ed accertati che gli output di ogni unità siano  conformi 
a quelli attesi, testandoli in qualunque condizione possibile si possa trovare la singola 
unità. Questi test fanno riferimento alla specifica dell'unità e utilizza dati in input 
capaci di provocare in output i dati attesi.
  \item Verifica strutturale(white box): questo modello parte dalla conoscenza  delle 
specifiche del progetto, e come in un sistema a scatola trasparente si analizzano i 
comportamenti specifici dell'unità e dei rispettivi metodi per verificarne la logica 
interna e il corretto funzionamento. In questi test deve essere preso in considerazione 
ogni cammino di esecuzione all'interno del modulo, quindi i casi di prova devono essere 
tutti adeguatamente progettati. 
\end{itemize}


Il piano dei test di unità(che dovrà essere chiaramente esposto al termine della 
progettazione in dettaglio) prevede che per ogni test siano elencati:

\begin{itemize}
  \item Unità o Modulo su cui sarà effettuato il test
  \item Dati in Input
  \item Output attesi e output ottenuti
  \item Funzionalità testate
  \item Obbiettivi del test
  \item Malfunzionamenti rilevati
  \item Costi e Rischi
\end{itemize}

L'obiettivo è quello di rintracciare tutti gli errori presenti all'interno del
codice ed una volta identificati, risolverli. Da sottolineare che come afferma la tesi di Dijkstra 
i test non possono dimostrare la totale assenza di errori.


\section{Metodi di Verifica}

\subsection{Documentazione}

\subsection{Analisi}

\subsection{Progettazione ad Alto Livello}

\subsubsection{Soddisfacimento di tutti i requisiti individuati}

Verificare la corrispondenza dei requisiti individuati in fase di analisi (vedi
cap. 5 del documento \emph{AnalisiDeiRequisiti-2.0.pdf}) con almeno un modulo
software previsto dalla specifica tecnica. Si consiglia di utilizzare la tabella di tracciamento dei requisiti con le relative componenti
software proposta all'interno del documento \emph{SpecificaTecnica-1.0.pdf}.
\\\\
Esito atteso: ci si aspetta di ritrovare all'interno della tabella tutti gli
stessi requisiti così come individuati in fase di analisi.
 
\subsubsection{Individuazione di elementi progettuali superflui}

Individuare tutti i moduli software proposti a livello di progettazione e
verificare che tutti svolgano una funzione richeista da uno dei requisiti individuati in fase
di analisi. Si consiglia di utilizzare la tabella di tracciamento dei requisiti
con le relative componenti software proposta all'interno del documento
\emph{SpecificaTecnica-1.0.pdf}.
\\\\
Esito atteso: ci si aspetta di ritrovare all'interno della tabella tutti i
moduli software previsti dalla progettazione.


\subsubsection{Corretta corrispondenza e tracciabilità tra i requisiti e i
moduli software}

Verificare che le funzioni dei moduli software soddisfino le richieste dei
requisiti con cui sono tracciati. Si consiglia di confrontare la descrizione
delle funzionalità fornite dai singoli moduli così come descritto in
\emph{SpecificaTecnica-1.0.pdf} con la descrizione dei singoli requisiti
proposta nel cap. 5 del documento \emph{AnalisiDeiRequisiti-2.0.pdf}).
\\\\
Esito atteso: ci si aspetta di trovare riscontro tra quello che esigono i
singoli requisito con le funzionalità descritte dai moduli a loro tracciati.


\subsubsection{Felssibilità e manutenibilità}

Verificare che il numero di moduli presente sia sufficientemente alto a coprire
in maniera efficace il numero di requisiti funzionali e che tutte le
funzionalità richieste siano distribuite il più possibile senza incentrare
tutto su pochi moduli costretti a fare tante cose. Controllare la coesione e
l'accoppiamento di ogni singolo modulo. Verificare inoltre la presenza e
l'utilizzo di pattern.
\\\\
Esito atteso: ci si aspetta di trovare un numero di moduli sufficientemente alto
in proporzione al numero di requisiti funzionali. Inoltre ci si aspetta di
rilevare un'alta coesione e un basso accoppiamento di tutti i moduli previsti,
favorito anche dall'utilizzo di un buon numero di pattern. 


% INIZIO CAPITOLO 3

\chapter{Gestione amministrativa della \\revisione}
\thispagestyle{fancy} % per lo stile di header e footer

\section{Comunicazione e risoluzione di anomalie}

Possiamo prevedere che la maggioranza delle anomalie verr\`a individuata in fase
di verifica. Ci\`o nonostante non possiamo escludere che vengano riscontrate
anche durante una qualsiasi fase di ciclo di vita, quindi non vogliamo limitare
il compito della comunicazione ai soli verificatori ma intendiamo estendere il
caso a tutti i membri del gruppo di lavoro.

\subsection{Comunicazione}

Per notificare anomalie dovr\`a essere usato lo strumento issue-tracker messo a
disposizione nella pagina \url{http://code.google.com/p/netmus/}. Per ogni
anomalia individuata si dovr\`a creare un ticket. Per la creazione e la struttura dei
singoli ticket fare riferimento al documento \emph{NormeDiProgetto-1.0.pdf} paragrafo omonimo.


\subsection{Gestione dell'anomalia}

Il verificatore che individua un'anomalia dovrà innanzitutto analizzare il
problema per valutare l'utilizzo di tempo e risorse necessarie per risolverlo.
In seguito verrà comunicato, a chi ne ha competenza, il tipo e l'ubicazione dell'errore (vedi sezione 3.1.1).
L'incaricato dovrà provvedere ad una possibile soluzione. Se il problema
fosse particolarmente grave, sarà necessario un incontro con i membri del gruppo
per cercare una soluzione. Qualora trovare una soluzione all'anomalia venga giudicato troppo dispendioso in termini di tempo o risorse si dovrà comunicare
al cliente l'anomalia stessa, la sua origine e l'intenzione di non trattarla.

\section{Trattamento delle discrepanze}

\`E inoltre compito dei verificatori individuare e segnalare la presenza di
discrepanze. Per notificare una discrepanza dovrà essere usato lo strumento
issue-tracker messo a disposizione nella pagina \url{http://code.google.com/p/netmus}. Per ogni discrepanza
individuata si creerà un ticket. Esso dovrà avere struttura simile a quella indicata nel
documento \emph{NormeDiProgetto-1.0.pdf}, ma la priorità assegnatagli dovrà essere quella
massima. I verificatori analizzeranno il problema, usando la tabella di
tracciabilità dei requisiti. Verrà trovato quale o quali di questi problemi non
rispettano le aspettative del cliente o, in alternativa, quale requisito non è
stato rispettato. Se il problema fosse risolvibile in tempi e costi ragionevoli
l'impegno sarà focalizzato nella soluzione di quest'ultimo. Altrimenti si dovrà
redarre un documento da consegnare al cliente con la descrizione accurata della
discrepanza.\\

Vanno incluse:

\begin{itemize}

\item eventuali responsabilità;
\item il preventivo dei tempi e dei costi necessari alla risoluzione;
\item una lista dei requisiti non soddisfatti.

\end{itemize}

In seguito si potranno prendere eventuali accordi con il cliente. In caso
contrario il progetto sarà esposto ad alto rischio di fallimento.

\section{Procedure di controllo di qualità di processo}

Esiste uno stretto legame tra qualità del processo di sviluppo e la qualità dei
prodotto sviluppati. Miglioramento del processo significa comprendere i processi
esistenti e modificarli per aumentare la qualità del software e/o diminuire i
costi e i tempi di sviluppo. Il miglioramento dei processi è un'attività ciclica
che si compone di tre stadi principali:

\begin{enumerate}
  
\item misurazione del processo: si analizza il prodotto secondo metriche
definite. Un miglioramento della valutazione secondo tali metriche è indice di
miglioramento di processo.
\item mnalisi del processo: il processo attuale viene valutato e vengono
identificati punti deboli e colli di bottiglia. Durante questo
studio solitamente vengono sviluppati i modelli di processo che descrivono il
processo stesso.
\item modifica del processo: vengono introdotte le modifiche al processo
identificate durante l'analisi.

\end{enumerate}


% INIZIO CAPITOLO 4

\chapter{Resoconto delle attività di verifica}
\thispagestyle{fancy} % per lo stile di header e footer

\section{Tracciamento componenti - requisiti}

\section{Dettaglio delle verifiche tramite analisi}

\section{Dettaglio delle verifiche tramite prove (test)}

\section{Dettaglio dell'esito delle revisioni}

% INIZIO CAPITOLO 5

\chapter{Pianificazione ed esecuzione del \\collaudo}
\thispagestyle{fancy} % per lo stile di header e footer

\section{Specifica della campagna di validazione \\(collaudo incluso)}
Si effettueranno tre tipi di test:

\begin{itemize}
	\item test di unità: effettuato al termine del disegno di dettaglio ed eseguito
in modo strutturale (white-box) o funzionale (black-box) su ciascuna unità; diverrà completo quando avrà provato tutte le unità definite entro le
componenti del progetto architetturale;
	\item test di integrazione: applicato alle componenti del progetto
architetturale;
	\item test di sistema: effettuato per verificare se il comportamento dinamico
del software aderisce ai requisiti. Esso può aver inizio solamente al
completamento del test di integrazione.
\end{itemize}

\section{Dettaglio dell'esito della campagna di validazione}
La campagna di validazione non è stata ancora eseguita.

\listoftables
\addcontentsline{toc}{chapter}{Indice Tabelle}
\listoffigures
\addcontentsline{toc}{chapter}{Indice Figure}
\end{document}

